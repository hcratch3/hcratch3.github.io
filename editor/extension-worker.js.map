{"version":3,"file":"extension-worker.js","sources":["webpack://GUI/webpack/bootstrap","webpack://GUI/./node_modules/scratch-vm/node_modules/minilog/lib/common/transform.js","webpack://GUI/./node_modules/scratch-vm/src/util/log.js","webpack://GUI/./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/util.js","webpack://GUI/./node_modules/scratch-vm/src/extension-support/extension-worker.js","webpack://GUI/(webpack)/buildin/global.js","webpack://GUI/./node_modules/scratch-vm/src/extension-support/argument-type.js","webpack://GUI/./node_modules/scratch-vm/src/extension-support/block-type.js","webpack://GUI/./node_modules/scratch-vm/src/dispatch/worker-dispatch.js","webpack://GUI/./node_modules/scratch-vm/src/dispatch/shared-dispatch.js","webpack://GUI/./node_modules/scratch-vm/node_modules/minilog/lib/web/index.js","webpack://GUI/./node_modules/scratch-vm/node_modules/minilog/lib/common/minilog.js","webpack://GUI/./node_modules/scratch-vm/node_modules/microee/index.js","webpack://GUI/./node_modules/scratch-vm/node_modules/minilog/lib/common/filter.js","webpack://GUI/./node_modules/scratch-vm/node_modules/minilog/lib/web/console.js","webpack://GUI/./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/color.js","webpack://GUI/./node_modules/scratch-vm/node_modules/minilog/lib/web/formatters/minilog.js","webpack://GUI/./node_modules/scratch-vm/node_modules/minilog/lib/web/array.js","webpack://GUI/./node_modules/scratch-vm/node_modules/minilog/lib/web/localstorage.js","webpack://GUI/./node_modules/scratch-vm/node_modules/minilog/lib/web/jquery_simple.js","webpack://GUI/./node_modules/scratch-vm/src/extension-support/target-type.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","var microee = require('microee');\n\n// Implements a subset of Node's stream.Transform - in a cross-platform manner.\nfunction Transform() {}\n\nmicroee.mixin(Transform);\n\n// The write() signature is different from Node's\n// --> makes it much easier to work with objects in logs.\n// One of the lessons from v1 was that it's better to target\n// a good browser rather than the lowest common denominator\n// internally.\n// If you want to use external streams, pipe() to ./stringify.js first.\nTransform.prototype.write = function(name, level, args) {\n  this.emit('item', name, level, args);\n};\n\nTransform.prototype.end = function() {\n  this.emit('end');\n  this.removeAllListeners();\n};\n\nTransform.prototype.pipe = function(dest) {\n  var s = this;\n  // prevent double piping\n  s.emit('unpipe', dest);\n  // tell the dest that it's being piped to\n  dest.emit('pipe', s);\n\n  function onItem() {\n    dest.write.apply(dest, Array.prototype.slice.call(arguments));\n  }\n  function onEnd() { !dest._isStdio && dest.end(); }\n\n  s.on('item', onItem);\n  s.on('end', onEnd);\n\n  s.when('unpipe', function(from) {\n    var match = (from === dest) || typeof from == 'undefined';\n    if(match) {\n      s.removeListener('item', onItem);\n      s.removeListener('end', onEnd);\n      dest.emit('unpipe');\n    }\n    return match;\n  });\n\n  return dest;\n};\n\nTransform.prototype.unpipe = function(from) {\n  this.emit('unpipe', from);\n  return this;\n};\n\nTransform.prototype.format = function(dest) {\n  throw new Error([\n    'Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:',\n    'var Minilog = require(\\'minilog\\');',\n    'Minilog',\n    '  .pipe(Minilog.backends.console.formatClean)',\n    '  .pipe(Minilog.backends.console);'].join('\\n'));\n};\n\nTransform.mixin = function(dest) {\n  var o = Transform.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\n\nmodule.exports = Transform;\n","const minilog = require('minilog');\nminilog.enable();\n\nmodule.exports = minilog('vm');\n","var hex = {\n  black: '#000',\n  red: '#c23621',\n  green: '#25bc26',\n  yellow: '#bbbb00',\n  blue:  '#492ee1',\n  magenta: '#d338d3',\n  cyan: '#33bbc8',\n  gray: '#808080',\n  purple: '#708'\n};\nfunction color(fg, isInverse) {\n  if(isInverse) {\n    return 'color: #fff; background: '+hex[fg]+';';\n  } else {\n    return 'color: '+hex[fg]+';';\n  }\n}\n\nmodule.exports = color;\n","/* eslint-env worker */\n\nconst ArgumentType = require('../extension-support/argument-type');\nconst BlockType = require('../extension-support/block-type');\nconst dispatch = require('../dispatch/worker-dispatch');\nconst TargetType = require('../extension-support/target-type');\n\nclass ExtensionWorker {\n    constructor () {\n        this.nextExtensionId = 0;\n\n        this.initialRegistrations = [];\n\n        dispatch.waitForConnection.then(() => {\n            dispatch.call('extensions', 'allocateWorker').then(x => {\n                const [id, extension] = x;\n                this.workerId = id;\n                this.extensionURL = extension;\n\n                try {\n                    importScripts(extension);\n\n                    const initialRegistrations = this.initialRegistrations;\n                    this.initialRegistrations = null;\n\n                    Promise.all(initialRegistrations).then(() => dispatch.call('extensions', 'onWorkerInit', id));\n                } catch (e) {\n                    dispatch.call('extensions', 'onWorkerInit', id, e);\n                }\n            });\n        });\n\n        this.extensions = [];\n    }\n\n    register (extensionObject) {\n        const extensionId = this.nextExtensionId++;\n        this.extensions.push(extensionObject);\n        const serviceName = `extension.${this.workerId}.${extensionId}`;\n        const promise = dispatch.setService(serviceName, extensionObject)\n            .then(() => dispatch.call('extensions', 'registerExtensionService', serviceName, this.extensionURL));\n        if (this.initialRegistrations) {\n            this.initialRegistrations.push(promise);\n        }\n        return promise;\n    }\n}\n\nglobal.Scratch = global.Scratch || {};\nglobal.Scratch.ArgumentType = ArgumentType;\nglobal.Scratch.BlockType = BlockType;\nglobal.Scratch.TargetType = TargetType;\n\n/**\n * Expose only specific parts of the worker to extensions.\n */\nconst extensionWorker = new ExtensionWorker();\nglobal.Scratch.extensions = {\n    register: extensionWorker.register.bind(extensionWorker)\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/**\n * Block argument types\n * @enum {string}\n */\nconst ArgumentType = {\n    /**\n     * Numeric value with angle picker\n     */\n    ANGLE: 'angle',\n\n    /**\n     * Boolean value with hexagonal placeholder\n     */\n    BOOLEAN: 'Boolean',\n\n    /**\n     * Numeric value with color picker\n     */\n    COLOR: 'color',\n\n    /**\n     * Numeric value with text field\n     */\n    NUMBER: 'number',\n\n    /**\n     * String value with text field\n     */\n    STRING: 'string',\n\n    /**\n     * String value with matrix field\n     */\n    MATRIX: 'matrix',\n\n    /**\n     * MIDI note number with note picker (piano) field\n     */\n    NOTE: 'note',\n\n    /**\n     * Inline image on block (as part of the label)\n     */\n    IMAGE: 'image'\n};\n\nmodule.exports = ArgumentType;\n","/**\n * Types of block\n * @enum {string}\n */\nconst BlockType = {\n    /**\n     * Boolean reporter with hexagonal shape\n     */\n    BOOLEAN: 'Boolean',\n\n    /**\n     * A button (not an actual block) for some special action, like making a variable\n     */\n    BUTTON: 'button',\n\n    /**\n     * Command block\n     */\n    COMMAND: 'command',\n\n    /**\n     * Specialized command block which may or may not run a child branch\n     * The thread continues with the next block whether or not a child branch ran.\n     */\n    CONDITIONAL: 'conditional',\n\n    /**\n     * Specialized hat block with no implementation function\n     * This stack only runs if the corresponding event is emitted by other code.\n     */\n    EVENT: 'event',\n\n    /**\n     * Hat block which conditionally starts a block stack\n     */\n    HAT: 'hat',\n\n    /**\n     * Specialized command block which may or may not run a child branch\n     * If a child branch runs, the thread evaluates the loop block again.\n     */\n    LOOP: 'loop',\n\n    /**\n     * General reporter with numeric or string value\n     */\n    REPORTER: 'reporter'\n};\n\nmodule.exports = BlockType;\n","const SharedDispatch = require('./shared-dispatch');\n\nconst log = require('../util/log');\n\n/**\n * This class provides a Worker with the means to participate in the message dispatch system managed by CentralDispatch.\n * From any context in the messaging system, the dispatcher's \"call\" method can call any method on any \"service\"\n * provided in any participating context. The dispatch system will forward function arguments and return values across\n * worker boundaries as needed.\n * @see {CentralDispatch}\n */\nclass WorkerDispatch extends SharedDispatch {\n    constructor () {\n        super();\n\n        /**\n         * This promise will be resolved when we have successfully connected to central dispatch.\n         * @type {Promise}\n         * @see {waitForConnection}\n         * @private\n         */\n        this._connectionPromise = new Promise(resolve => {\n            this._onConnect = resolve;\n        });\n\n        /**\n         * Map of service name to local service provider.\n         * If a service is not listed here, it is assumed to be provided by another context (another Worker or the main\n         * thread).\n         * @see {setService}\n         * @type {object}\n         */\n        this.services = {};\n\n        this._onMessage = this._onMessage.bind(this, self);\n        if (typeof self !== 'undefined') {\n            self.onmessage = this._onMessage;\n        }\n    }\n\n    /**\n     * @returns {Promise} a promise which will resolve upon connection to central dispatch. If you need to make a call\n     * immediately on \"startup\" you can attach a 'then' to this promise.\n     * @example\n     *      dispatch.waitForConnection.then(() => {\n     *          dispatch.call('myService', 'hello');\n     *      })\n     */\n    get waitForConnection () {\n        return this._connectionPromise;\n    }\n\n    /**\n     * Set a local object as the global provider of the specified service.\n     * WARNING: Any method on the provider can be called from any worker within the dispatch system.\n     * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.\n     * @param {object} provider - a local object which provides this service.\n     * @returns {Promise} - a promise which will resolve once the service is registered.\n     */\n    setService (service, provider) {\n        if (this.services.hasOwnProperty(service)) {\n            log.warn(`Worker dispatch replacing existing service provider for ${service}`);\n        }\n        this.services[service] = provider;\n        return this.waitForConnection.then(() => this._remoteCall(self, 'dispatch', 'setService', service));\n    }\n\n    /**\n     * Fetch the service provider object for a particular service name.\n     * @override\n     * @param {string} service - the name of the service to look up\n     * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found\n     * @protected\n     */\n    _getServiceProvider (service) {\n        // if we don't have a local service by this name, contact central dispatch by calling `postMessage` on self\n        const provider = this.services[service];\n        return {\n            provider: provider || self,\n            isRemote: !provider\n        };\n    }\n\n    /**\n     * Handle a call message sent to the dispatch service itself\n     * @override\n     * @param {Worker} worker - the worker which sent the message.\n     * @param {DispatchCallMessage} message - the message to be handled.\n     * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate\n     * @protected\n     */\n    _onDispatchMessage (worker, message) {\n        let promise;\n        switch (message.method) {\n        case 'handshake':\n            promise = this._onConnect();\n            break;\n        case 'terminate':\n            // Don't close until next tick, after sending confirmation back\n            setTimeout(() => self.close(), 0);\n            promise = Promise.resolve();\n            break;\n        default:\n            log.error(`Worker dispatch received message for unknown method: ${message.method}`);\n        }\n        return promise;\n    }\n}\n\nmodule.exports = new WorkerDispatch();\n","const log = require('../util/log');\n\n/**\n * @typedef {object} DispatchCallMessage - a message to the dispatch system representing a service method call\n * @property {*} responseId - send a response message with this response ID. See {@link DispatchResponseMessage}\n * @property {string} service - the name of the service to be called\n * @property {string} method - the name of the method to be called\n * @property {Array|undefined} args - the arguments to be passed to the method\n */\n\n/**\n * @typedef {object} DispatchResponseMessage - a message to the dispatch system representing the results of a call\n * @property {*} responseId - a copy of the response ID from the call which generated this response\n * @property {*|undefined} error - if this is truthy, then it contains results from a failed call (such as an exception)\n * @property {*|undefined} result - if error is not truthy, then this contains the return value of the call (if any)\n */\n\n/**\n * @typedef {DispatchCallMessage|DispatchResponseMessage} DispatchMessage\n * Any message to the dispatch system.\n */\n\n/**\n * The SharedDispatch class is responsible for dispatch features shared by\n * {@link CentralDispatch} and {@link WorkerDispatch}.\n */\nclass SharedDispatch {\n    constructor () {\n        /**\n         * List of callback registrations for promises waiting for a response from a call to a service on another\n         * worker. A callback registration is an array of [resolve,reject] Promise functions.\n         * Calls to local services don't enter this list.\n         * @type {Array.<Function[]>}\n         */\n        this.callbacks = [];\n\n        /**\n         * The next response ID to be used.\n         * @type {int}\n         */\n        this.nextResponseId = 0;\n    }\n\n    /**\n     * Call a particular method on a particular service, regardless of whether that service is provided locally or on\n     * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone\n     * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be\n     * transferred to the worker, and they should not be used after this call.\n     * @example\n     *      dispatcher.call('vm', 'setData', 'cat', 42);\n     *      // this finds the worker for the 'vm' service, then on that worker calls:\n     *      vm.setData('cat', 42);\n     * @param {string} service - the name of the service.\n     * @param {string} method - the name of the method.\n     * @param {*} [args] - the arguments to be copied to the method, if any.\n     * @returns {Promise} - a promise for the return value of the service method.\n     */\n    call (service, method, ...args) {\n        return this.transferCall(service, method, null, ...args);\n    }\n\n    /**\n     * Call a particular method on a particular service, regardless of whether that service is provided locally or on\n     * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone\n     * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be\n     * transferred to the worker, and they should not be used after this call.\n     * @example\n     *      dispatcher.transferCall('vm', 'setData', [myArrayBuffer], 'cat', myArrayBuffer);\n     *      // this finds the worker for the 'vm' service, transfers `myArrayBuffer` to it, then on that worker calls:\n     *      vm.setData('cat', myArrayBuffer);\n     * @param {string} service - the name of the service.\n     * @param {string} method - the name of the method.\n     * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.\n     * @param {*} [args] - the arguments to be copied to the method, if any.\n     * @returns {Promise} - a promise for the return value of the service method.\n     */\n    transferCall (ser
